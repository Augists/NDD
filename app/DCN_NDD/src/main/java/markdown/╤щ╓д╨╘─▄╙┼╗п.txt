当前结果start traverse
start.size()48
endEndpoint.size()48
moved_aps.size(): 496
reachability:528
total_time:1057.667806

start.size()48
endEndpoint.size()48
moved_aps.size(): 14
reachability:560
total_time:92.861597
time per inserted rule :2.321539925

start.size()48
endEndpoint.size()48
moved_aps.size(): 0
reachability:560
total_time:0.052298
time per inserted rule :0.052298

start.size()48
endEndpoint.size()49
moved_aps.size(): 7
reachability:567
total_time:12.190296
time per inserted rule :0.32946745945945943

start.size()48
endEndpoint.size()50
moved_aps.size(): 7
reachability:574
total_time:16.694105
time per inserted rule :0.45119202702702704

start.size()56
endEndpoint.size()58
moved_aps.size(): 105
reachability :594
total_time:432.155092
time per inserted rule :3.6012924333333336
616



# 仅有vni的情况下的时间复杂度大约在1s，增量在400ms

优化方法：
主要的时间都花费到了repair的过程

        //这个函数是把解封装后的内容进行repair，保证堆栈里的内容始终被算子所约束，把过程中的被转发掉的内容去除掉
        //如果我记录一下呢，每次encap后，添加保存一个变量，记录中间被过滤的内容，保留一下中间丢失的内容。
        //我做的repair的过程中，目的是恢复这个过程
        //我的这个起点也应该是当转发出现了分割的时候，需要repair一下，把堆栈的内容修复一下，防止后面出现问题
        //还是从repair入手吧
        //我现在的做法是，拆出来，检查一下有没有问题
        //我也想到一个做法，就是中间记录一些哪些内容被转发掉了。
        //比如从vpn到encapvni，到encapip，encapip的时候进行了一次分裂，


现在开始想办法实现更接近于结果的内容。
repair 的触发点是当发生了端口内容的变化，需要把堆栈的内容都修改一下

比如在某个端口，出现了aps的大小小于tobeadded的情况。
说明需要修复堆栈
从这个element开始，逐渐前，也就是第一段的逆运算过程。
根据history和堆栈的内容进行变化。
只看当前的和上一个是啥。
如果上一个是nat
如果上一个是forward：根据aps，变化一下