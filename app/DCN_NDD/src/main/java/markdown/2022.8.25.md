# 结果

|  更新序号   | 网络建立时间/ms | 更新后原子总数 | 受影响的原子数 | 验证时间/ms |
| :---------: | --------------: | :------------: | :------------: | ----------: |
|    base     |      45170.2851 |      5467      |      5467      |  63517.7440 |
| post0_base  |        259.1488 |      5467      |      154       |   6202.2567 |
| post1_post0 |          1.8218 |      5467      |       0        |      0.0609 |
| post2_post1 |       1787.4345 |      5544      |       77       |    412.1251 |
| post3_post2 |       2239.0717 |      5621      |       77       |    322.9766 |
| post4_post3 |      37964.7131 |      6776      |      1155      |  17543.9554 |



# 结果解释



## 原子数量变化原因

- update1：多出来了0个原子，移动了154个原子。为vpn0和vpn4下面添加了两个原本就存在的ip，把一部分原子从default移动到了vxlan端口
- update2：acl，不影响结果
- update3：多出来了77个原子，移动了77个，77=1\*7\*11，6个vni，10个src，分别把各自的区域划分成了7个和11个。在dstip域增加了一个新的ip，和之前的不一样，因此是77个。
- update4：同update3
- update5：增加了1个vni，和4种转发行为不同的ip。原子总数=6776=77\*8\*11。移动的原子数是6776-5621=1155，都是新增的



## 网络建立时间和验证时间的分析

- update1，受影响的原子较大（154），但是网络建立时间很短，验证时间长。并且因为每次变化都是以77为单位，导致中间会触发repair机制
  - 
- update3和4，受影响等价类小，建立时间长，但是验证时间很短。





# mnv的异同点

![image-20220825192921127](C:\Users\wbSun\AppData\Roaming\Typora\typora-user-images\image-20220825192921127.png)

在第五次更新这个角度上

趋势都是逐渐增加，主要解释的是mnv为什么比mnv-效率高这么多。



在同样是leaf节点这个数据集上，要解释的是不同更新之间出现的区别





# dna

外部事件而被的变化应很小

确定自己的规则是否是有用的，这个是很好确定的，原因是比如添加了一个过滤，就只看新子网就可以了。

困难的是，怎么确定我插入的规则有没有副作用。



# 总结归纳
katra的原子划分的依据
每个原子依旧满足以下条件
原子并起来是true，原子互不相交。
原子在每个设备上匹配的规则是相同的。做出的行为和改变是相同的。

解释以下两点，同一区域的不同封装为什么能放到同一层
不同区域的封装为什么不能被化简。
1. 同一区域的不同层，只看最外层的内容，根据堆栈的外层来判断结果，这样原子数量的乘法就变成了加法
2. 假如说同一层的vxlan区域和dstip区域，各自的转发行为肯定各不相同，各个域之间的肯定会出现一系列划分，将划分总结起来会怎么样
如果说完全使用一个区域划分等价类会发生什么。比如说，我给定一个最大的域，32位的ip，所有的都在这个上面划分，前面再给定一个区域来指定当前的协议是什么。
比如00是dst，01是src，不过同样具有很大的问题，需要提前知道所有的内容。不然不能实现加法

可能的方向，修改一下环路检测的方式。检查一下环路检测的内容，检查一下原子计算结果


# apkeep element引入的内容开销问题
第一步优化，保证每个hashset里面保存的内容是同一个integer，使得不同hashset里面不会引起更多的内容开销，保证每一个原子只保存一个实例。不过对于hashset自身的开销，还是一个不可知的情况。

单实例integer:526，不限制int：696
integer空间占用大小是16个字节
999500*(12-1)*16 /1024 /1024 =167.7627563476563
696-526=170

4632.11336517334 6312.913330078125    1680.8
9,999,500 * 11 * 16 /1024 /1024 =1678.382873535156 m

该问题再网络中的实际影响，假设有N个设备，原子数为M，造成的额外内存使用大概是，M*(N-1)*16，占用比大概是



M*(N-1) \*16 / M*N\*

下一个疑问，原子数目的可能方向和内容占用的可能方向。如果我优化了

如何减少hashset本身的开销:这个就不考虑了

预期的目标，内存的开销具有极大的可扩展性，几万个element的情况下也要保持良好的增长速度。

如何从使用的角度来控制内存的使用开销，尽量保持每个原子存在一个实例。当前问题的情况是，每个element上都保存了integer的set，这个set本身的含义是，保留了设备端口的端口谓词
设备的端口谓词必须是要保留一个设备，端口的映射关系，首先是任意两个原子肯定是不一样的，总会发生分割。几万个element的时候，肯定会出现一大堆端口，




2.88
3.03
2.8?
3.22
3.14
3.53


