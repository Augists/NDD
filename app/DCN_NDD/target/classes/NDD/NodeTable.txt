package NDD;

import java.util.HashMap;
import java.util.Map;

import javafx.util.*;

public class NodeTable {
    public HashMap<HashMap<NDD, Integer>, Pair<NDD, Integer>> NDDs;

    public NodeTable() {
        NDDs = new HashMap<HashMap<NDD, Integer>, Pair<NDD, Integer>>();
    }

    public static boolean test = false;
    public static int mkCount = 0;

    public NDD mk(int field, HashMap<NDD, Integer> port_pred) // ensure that all used node are refed before invoking
    {
        if (port_pred.size() == 1) // redundant node
        {
            for (Map.Entry<NDD, Integer> entry : port_pred.entrySet()) {
                if (entry.getValue() == 1)
                    return entry.getKey();
            }
        }
        if (!NDDs.containsKey(port_pred)) // create new node
        {
            if(test)mkCount++;
            NDD ret = new NDD(field, port_pred);
            NDDs.put(port_pred, new Pair<NDD, Integer>(ret, 0));
            for (Map.Entry<NDD, Integer> entry : port_pred.entrySet()) {
                NDD next = entry.getKey();
                if (next == NDD.NDDFalse || next == NDD.NDDTrue) {
                    continue;
                }
                Pair<NDD, Integer> iter = NDDs.get(next.edges);
                Pair<NDD, Integer> iter_new = new Pair<NDD, Integer>(iter.getKey(), iter.getValue() + 1);
                NDDs.put(next.edges, iter_new);
            }
            return ret;
        } else // find
        {
            for (Map.Entry<NDD, Integer> entry : port_pred.entrySet()) {
                NDD.bdd.deref(entry.getValue());
            }
            return NDDs.get(port_pred).getKey();
        }
    }

    public NDD ref(NDD a) {
        if(a == NDD.NDDFalse || a == NDD.NDDTrue)return a;
        // System.out.println();
        // System.out.println("ref:"+a);
        // System.out.println("ref:"+a.edges);
        Pair<NDD, Integer> iter = NDDs.get(a.edges);
        Pair<NDD, Integer> iter_new = new Pair<NDD, Integer>(iter.getKey(), iter.getValue() + 1);
        NDDs.put(a.edges, iter_new);
        return a;
    }

    public void deref(NDD a) {
        if(a == NDD.NDDFalse || a == NDD.NDDTrue)return;
        Pair<NDD, Integer> iter = NDDs.get(a.edges);
        Pair<NDD, Integer> iter_new = new Pair<NDD, Integer>(iter.getKey(), iter.getValue() - 1);
        if (iter_new.getValue() > 0) {
            NDDs.put(a.edges, iter_new);
        } else if (iter_new.getValue() == 0) {
            delete(a);
        } else {
            System.out.println("error: ret count less than 0");
        }
    }

    public void testAndDelete(NDD a)
    {
        if(a == NDD.NDDFalse || a == NDD.NDDTrue)return;
        Pair<NDD, Integer> iter = NDDs.get(a.edges);
        if(iter != null && iter.getValue() == 0)
        {
            // System.out.println();
            // System.out.println("testAndDelete:"+a);
            delete(a);
        }
    }

    private void delete(NDD a) {
        for (Map.Entry<NDD, Integer> entry : a.edges.entrySet()) {
            NDD next = entry.getKey();
            NDD.bdd.deref(entry.getValue());
            if (next == NDD.NDDFalse || next == NDD.NDDTrue) {
                continue;
            }
            deref(next);
        }
        NDDs.remove(a.edges);
    }
}